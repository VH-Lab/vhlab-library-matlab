function X = csdDataProcessing(path,tfile,header,data,tbefore,tafter,channels,transition,i_initial,rows,columns)
%csdDataProcessing
%To create a cell 'X' that contains local field potential (LFP) data for the number of grid color flips
%for the 300 grids corresponding to each of the 16 electrodes.

%Note:
%For clarity purposes, we assume that the average number of trigger times per grid over the course
%of the experiment is 620 times. Because 100ms or 0.1s of data is taken in, there
%should be 25000data points/s * 0.1s = 2500 data points. However,
%'fastread' downsamples these data points by taking in every 83rd data
%points. Therefore, there are only 2500 data points/83 = 30.12 data points.
%This is rounded up to 31 data points.

%The cell 'X' does not take into account the ordering of the
%channels/electrodes based on the depth. The depth will be taken into account later.
%For function optimization, it will be wise to take into account the depth
%at this step; however, the portions that perform this function in
%following functions will need to be deleted to avoid double usage.

%If you wish to change the data acquisition for different channels, please
%change the 1:16 in lines 60 and 73.

%Example:
%X = super2('/Users/dennisou/Desktop/','t00001','vhlvanaloginput.vlh','vhlvanaloginput.vld',50,100,2:17,0,1,15,20)

%Updates:
%03-03-2014 - added saving functionality

%%
%Test on 16 channels:
%A = [];
%A = GetSGStimTriggers('/Users/dennisou/Desktop/','t00001',1,0);
%myheader = readvhlvheaderfile(['/Users/dennisou/Desktop/' filesep 't00001' filesep 'vhlvanaloginput.vlh']);
%[T,LFP] = readvhlvdatafile(['/Users/dennisou/Desktop/' filesep 't00001' filesep 'vhlvanaloginput.vld'],myheader,2:17,0,200);

%Test on 32 channels:
% myheader = readvhlvheaderfile(['/Users/dennisou/Desktop/' filesep 't00001' filesep 'vhlvanaloginput.vlh']);
% [T,LFP] = readvhlvdatafile(['/Users/dennisou/Desktop/' filesep 't00001' filesep 'vhlvanaloginput.vld'],myheader,2,0,20,'UseWaitBar',1,'WaitBarMessage','Extracting all data (Cycle 2/3)...');
% 
% figure();
% for i = 1:32
%     subplot(4,8,i)
%     plot(T(:,i),LFP(:,i))
% end

%%
%Part A: To store all of the trigger times for all grids into a cell A.

%Cell A contains all of the trigger times for all 300 grids. Cell A should
%be 1 row by 300 columns. Each element should be 1 row by (# trigger
%times) columns.
A = {};

wbar = waitbar(0,'Extracting stim timestamps (Cycle 1/3)...');
set(0, 'CurrentFigure', 1);
for i = 1:rows*columns;  %loops through all 300 grids
    A{i} = GetSGStimTriggers(path,tfile,i,transition);    %Input the trigger times for grid number i into cell A
    display(i)  %to track progress of this loop. It should stop at i = 300.
    waitbar((i)/(rows*columns),wbar,'Extracting stim timestamps (Cycle 1/3)...')
end
waitbar((i)/(rows*columns),wbar,'Complete!')
close(wbar)

%%
%Part B: To store "all" of the relevant LFP data into the array 'LFP'.

%Since it is time consuming to iterate through all elements in 'A' to find
%the largest trigger time (LTT), I just assumed that by taking the largest
%trigger time for grid 1 and multiplying it by 1.2 will yield a trigger
%time greater than LTT. 1.2 is an extremely conservative estimate and it can be
%changed accordingly.
max_T = max(A{1})*1.2;  %we can definitely make this part more efficient.***

myheader = readvhlvheaderfile([path filesep tfile filesep header]); %'myheader' outputs detailed information regarding the data acquisition equipment

%In the 'myheader' file, you can see ai0:31. This corresponds to the
%channels of two electrodes with ai31 being the sink. In terms of
%'readvhlvdatafile', you will need to add 1 for the channel values. For
%example, ai0:31 corresponds to channels 1 to 32. Specifically, electrode 1
%contains channels 1 to 16 and electode 2 contains channels 17 to 32. The
%'T' output generated by the next line acts purely as a placeholder to
%output 'LFP' and will not be used.

%[T,LFP_unfiltered] = readvhlvdatafile2([path filesep tfile filesep data],myheader,channels,0,max_T);
[T,LFP_unfiltered] = readvhlvdatafile([path filesep tfile filesep data],myheader,channels,0,max_T,'UseWaitBar',1,'WaitBarMessage','Extracting all data (Cycle 2/3)...');

LFP = sgolayfilt(double(LFP_unfiltered),1,417); %filters out 60 cycle alternating current noise

%To account for the shift time. The scale is usually very close to 1 so
%could be ignored.
location = [path tfile];
[shift] = vhlv_sync2spike2(location);

%%
%Part C: To sort the LFP data in array 'LFP' into a cell 'X' that has 16
%rows and 300 columns. 16 rows correspond to 16 channels and 300 columns
%correspond to 300 grids. Each element in cell 'X' contains 620 rows and 31
%columns. 620 rows correspond to the average number of trigger times per
%grid and 31 columns correspond to the number of data points in the 100ms
%or 0.1s timeframe. Do note that the number of trigger times per cell
%varies and this is why a cell is used for memory storage as opposed to an
%array.
X = {};

wbar = waitbar(0,'Extracting relevant data (Cycle 3/3)...');
set(0, 'CurrentFigure', 1);
for i = i_initial:length(channels)    %loops 16 times since there are that many channels
    for j = 1:length(A)  %loops 300 times since there are that many grids
        for k = 1:length(A{j})  %loops through number of trigger times for grid 'j' which approximately 620 triggers
            t1 = A{j}(k)-tbefore-shift;   %onset of trigger minus the time that user wishes to start recording from
            t2 = A{j}(k)+tafter-shift;   %time that user wishes to end recording after the onset of trigger
            LFP2 = csdDownsampling(LFP,i,t1,t2);   %'fastread downsamples the data so that 'X' is sufficiently small enough for storage on my laptop
            %Make sure to subtract the negative shift times (basically
            %adding them) from t1 and t2. The 'shift times' are indicative
            %of the latency time between spike2 and labview
            X{i,j}(k,:) = LFP2; %placing the filtered and downsampled data into the appropriate location in 'X'
        end
        display(i)  %to track the progress of the outer. This should end at 16.
        display(j)  %to track the progress of the inner loop. This should end at 300. 'display(k)' is not shown since it iterates too fast and is therefore a bad indicator of loop tracking.
        waitbar(((i-1)*length(A)+j)/(length(channels)*length(A)),wbar,'Extracting relevant data (Cycle 3/3)...')
        if (mod(i,1) == 0)  %this if statement saves cell 'X' after every iteration. This way if the function or computer were to crash, progress is being saved continuously.
            current = pwd;  %the if statement in the previous line could be eliminated...
            cd(location);
            if transition == 0
                Xw2b = X;
                save([tfile 'w2b'],'Xw2b');
            elseif transition == 1
                Xb2w = X;
                save([tfile 'b2w'],'Xb2w');
            end
            cd(current);
        end
    end
end
waitbar(((i-1)*length(A)+j)/(length(channels)*length(A)),wbar,'Complete!')
close(wbar)

end

%Question:
%How do I get the spike2 to Labview delay time and also where do I
%take this feature into account?
%
%Answer: Use vhlv_sync2spike2(pwd) where pwd = /Users/dennisou/Desktop/t00001
%vhlv_sync2spike2('/Users/dennisou/Desktop/t00001')
%to show accuracy of 'scale',use... sprintf('%0.15f',scale)

