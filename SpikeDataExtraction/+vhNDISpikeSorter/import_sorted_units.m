function import_sorted_units(ndiSession, probe)
% IMPORT_SORTED_UNITS - Import sorted spike units into NDI session
%
%   IMPORT_SORTED_UNITS(NDISESSION, PROBE)
%
%   Imports sorted spike units for the specified PROBE into the NDI session.
%   This function looks for spike sorting output files (spike times and cluster info)
%   generated by the vhNDISpikeSorter pipeline and creates NDI neuron elements.
%
%   NDISESSION is an ndi.session object.
%   PROBE is an ndi.probe object.

    arguments
        ndiSession {mustBeA(ndiSession, 'ndi.session')}
        probe {mustBeA(probe, 'ndi.probe')}
    end

    settingsDir = vhNDISpikeSorter.parameters.spikeSortingPath(ndiSession);
    
    pName = probe.elementstring();
    pName = char(pName); pName(isspace(pName)) = '_'; pName = replace(pName, '|', '_');
    
    et = probe.epochtable();
    
    disp(['Scanning sorted units for probe: ' probe.elementstring()]);
    
    % Identify all clusters across all epochs
    clusterData = containers.Map('KeyType', 'double', 'ValueType', 'any');
    
    for j = 1:numel(et)
        epochID = et(j).epoch_id;
        
        % Use getClusterSpikeTimesPrefix to find files
        prefix = vhNDISpikeSorter.parameters.getClusterSpikeTimesPrefix(probe, epochID);
        pat = fullfile(settingsDir, [prefix '*.txt']);
        files = dir(pat);
        
        if isempty(files)
            % disp(['No sorted unit files found for epoch ' epochID]);
            continue;
        else
            disp(['Found ' num2str(length(files)) ' sorted unit files for epoch ' epochID]);
        end
        
        for k = 1:length(files)
            fname = files(k).name;
            % Parse cluster ID: suffix .txt
            % prefix is sorted_spiketimes_PNAME_EPOCHID_
            cStr = fname(length(prefix)+1 : end-4);
            cID = str2double(cStr);
            if isnan(cID), continue; end
            
            times = load(fullfile(settingsDir, fname), '-ascii');
            
            % Info file
            infoFile = vhNDISpikeSorter.parameters.getClusterInfoFilename(probe, cID);
            infoFullPath = fullfile(settingsDir, infoFile);
            quality = '';
            
            if exist(infoFullPath, 'file')
                tmp = load(infoFullPath);
                if isfield(tmp, 'clusterinfo')
                    if isfield(tmp.clusterinfo, 'quality_label')
                        quality = tmp.clusterinfo.quality_label;
                    elseif isfield(tmp.clusterinfo, 'qualitylabel')
                        quality = tmp.clusterinfo.qualitylabel;
                    end
                end
            end
            
            % Skip if quality is 'not usable' or 'garbage'
            if strcmpi(quality, 'not usable') || strcmpi(quality, 'garbage')
                continue;
            end

            if ~isKey(clusterData, cID)
                clusterData(cID) = struct('epochID', {}, 'times', {}, 'quality', {});
            end
            s = clusterData(cID);
            s(end+1).epochID = epochID;
            s(end).times = times;
            s(end).quality = quality;
            clusterData(cID) = s;
        end
    end
    
    keys = clusterData.keys;
    disp(['Found ' num2str(length(keys)) ' unique clusters.']);
    
    for k = 1:length(keys)
        cID = keys{k};
        dataStruct = clusterData(cID);
        
        neuron_name = [pName '_cluster' sprintf('%03d', cID)];
        disp(['Importing ' neuron_name '...']);
        
        element_neuron = ndi.neuron(ndiSession, neuron_name, probe.reference, 'spikes', probe, 0, [], []);
        
        qLabel = '';
        if ~isempty(dataStruct)
            qLabel = dataStruct(1).quality;
        end
        
        neuron_extracellular = struct();
        neuron_extracellular.cluster_index = cID;
        neuron_extracellular.quality_label = qLabel;
        
        all_waveforms = [];
        h_struct = [];
        
        for m = 1:length(dataStruct)
            eID = dataStruct(m).epochID;
            ts = dataStruct(m).times;
            
            % Load extracted times/waves to find waveform snippets
            tFile = fullfile(settingsDir, vhNDISpikeSorter.parameters.getSpikeTimesFilename(probe, eID));
            wFile = fullfile(settingsDir, vhNDISpikeSorter.parameters.getSpikeWaveformFilename(probe, eID));
            
            if exist(tFile, 'file') && exist(wFile, 'file')
                fid = fopen(tFile, 'r', 'ieee-le');
                all_ts = fread(fid, 'float64');
                fclose(fid);
                
                [L, locs] = ismembertol(ts, all_ts, 1e-6); 
                indices = locs(L);
                
                if ~isempty(indices)
                    [w_epoch, h] = readvhlspikewaveformfile(wFile);
                    if isempty(h_struct), h_struct = h; end

                    % w_epoch is S x C x N
                    w_unit = w_epoch(:, :, indices);
                    
                    if isempty(all_waveforms)
                        all_waveforms = w_unit;
                    else
                        all_waveforms = cat(3, all_waveforms, w_unit);
                    end
                end
            end
        end
        
        mean_wave = [];
        if ~isempty(all_waveforms)
            mean_wave = mean(all_waveforms, 3);
        end
        
        neuron_extracellular.mean_waveform = mean_wave;
        
        if ~isempty(mean_wave)
            neuron_extracellular.number_of_channels = size(mean_wave, 2);
            neuron_extracellular.number_of_samples_per_channel = size(mean_wave, 1);
        else
            neuron_extracellular.number_of_channels = 0;
            neuron_extracellular.number_of_samples_per_channel = 0;
        end

        % Quality number mapping
        % Using integer scale: Excellent=4, Good=3, Fair=2, Poor=1, Multi=0, Unselected=0, Garbage=-1
        quality_map = containers.Map({'excellent', 'good', 'fair', 'poor', 'multi', 'garbage', 'multi-unit', 'unselected', 'not usable'}, ...
            {4, 3, 2, 1, 0, -1, 0, 0, -1});

        qNum = 0; % Default
        if ~isempty(qLabel)
             lowQ = lower(qLabel);
             if isKey(quality_map, lowQ)
                 qNum = quality_map(lowQ);
             end
        end
        neuron_extracellular.quality_number = int8(qNum);

        % Waveform sample times
        sr = 20000; % Default fallback
        if ~isempty(h_struct)
            if isfield(h_struct, 'samplerate')
                sr = h_struct.samplerate;
            elseif isfield(h_struct, 'sampling_rate')
                sr = h_struct.sampling_rate;
            elseif isfield(h_struct, 'frequency')
                sr = h_struct.frequency;
            end
        end

        num_samples = neuron_extracellular.number_of_samples_per_channel;
        if num_samples > 0
            neuron_extracellular.waveform_sample_times = (0:num_samples-1) / sr;
        else
            neuron_extracellular.waveform_sample_times = [];
        end

        neuron_doc = ndi.document('neuron_extracellular', ...
            'neuron_extracellular', neuron_extracellular, ...
            'base.session_id', ndiSession.id());
        neuron_doc = neuron_doc.set_dependency_value('element_id', element_neuron.id());
        ndiSession.database_add(neuron_doc);
        
        for m = 1:length(dataStruct)
            eID = dataStruct(m).epochID;
            ts = dataStruct(m).times;
            element_neuron.addepoch(eID, ndi.time.clocktype('dev_local_time'), ...
                [0 Inf], ts(:), ones(size(ts(:))));
        end
        disp(['Imported ' neuron_name]);
    end
end
